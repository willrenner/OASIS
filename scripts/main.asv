clc;clear;
hWaitbar = waitbar(0, 'Running...', 'Name', 'AARC','CreateCancelBtn','delete(gcbf)');
fileID = fopen("../logs/abcd.txt", 'a'); %appends to end of file, or creates file and writes to it
format shortg; %smart formating

global leadScrewLead;
global numSteps;
global currentStep;
global prevTime
global directionCmd;
currentStep = 0;
leadScrewLead = 8; %mm/rev
numSteps = 200; %steps/rev, 1.8deg/step
directionCmd = "down";

pulsePin = "D1";
directionPin = "D2";
limitSwitchPin = "D3";

currentYpos = 0; %once limit switch is reached


rop = 10; %mm/min
timePerStep = getTimeFromROP(rop); %calculate timePerStep
run = true;
homing = true;

prevTime = tic;


while(run)
    while(homing)
        if (readDigitalPin(a, limitSwitchPin) == 0)% not at switch yet
            timeSincePrev = toc(prevTime);
            checkIfTimeToStep(timeSincePrev);
            timePerStep_ = getTimeFromROP(rop);
        elseif (readDigitalPin(a, limitSwitchPin) == 1) % reached the switch
            homing = false;
            break;
        end
    end
    timeSincePrev = toc(prevTime);
    checkIfTimeToStep(timeSincePrev);
    timePerStep = getTimeFromROP(rop); %calculate timePerStep
    currentYpos = currentStep / numSteps * leadScrewLead; %mm from limit switch
end





function timePerStep_ = getTimeFromROP(ropIn) %ROP in mm/min
    global leadScrewLead;
    global numSteps;
    if (ropIn <= 1) %less than 1 mm per minute, just return max time per step so it won't move
        timePerStep_ = 9999; %sec/step
    else
        stepperRevSpeedCmd = ropIn / leadScrewLead / 60; %rev/sec
        stepperRevSpeedCmd = stepperRevSpeedCmd * numSteps; %steps/sec
        timePerStep_ = 1 / stepperRevSpeedCmd; %sec/step
    end
end

function checkIfTimeToStep(timeSincePrev_) %****** wont work if  timeSincePrev >= 2*time per step, means will skip steps
    global directionCmd;
    if (timeSincePrev_ >= timePerStep)
        if (timeSincePrev >= timePerStep * 2)
            disp("Skipped at least one step"); %error check
        end
        stepOnce(directionCmd); %step stepper motor
    end
    
end

function stepOnce(direction) 
    global currentStep;
    global prevTime;
%     if (direction == "down")
%         writeDigitalPin(a, directionPin, 1) %1 for down?
%         writeDigitalPin(a, pulsePin, 1); %each step happens per pulse
%         %sleep for a tiny bit??
%         writeDigitalPin(a, pulsePin, 0);
%     elseif (direction == "up")
%         writeDigitalPin(a, directionPin, 0) %0 for up?
%         writeDigitalPin(a, pulsePin, 1); %each step happens per pulse
%         %sleep for a tiny bit??
%         writeDigitalPin(a, pulsePin, 0);
%     end
        currentStep = currentStep + 1; %increment stepper motor step
        disp("Step count: " +  currentStep);
        prevTime = tic;
end

funcion activate